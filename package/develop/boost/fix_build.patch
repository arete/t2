--- boost_1_54_0/libs/conversion/test/lexical_cast_integral_types_test.cpp.vanilla	2013-11-11 13:18:08.679124562 +0100
+++ boost_1_54_0/libs/conversion/test/lexical_cast_integral_types_test.cpp	2013-11-11 13:18:31.120123786 +0100
@@ -48,7 +48,7 @@
 #define BOOST_LCAST_NO_WCHAR_T
 #endif
 
-#if (defined(BOOST_LCAST_HAS_INT128) && !defined(__GNUC__)) || GCC_VERSION > 40700
+#if defined(BOOST_HAS_INT128) && (!defined(__GNUC__) || __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ > 6))
 #define BOOST_LCAST_HAS_INT128
 #endif
 
--- boost_1_54_0/boost/lexical_cast.hpp.vanilla	2013-11-11 13:17:18.215126306 +0100
+++ boost_1_54_0/boost/lexical_cast.hpp	2013-11-11 13:17:54.808125041 +0100
@@ -69,7 +69,8 @@
     throw_exception(bad_lexical_cast(typeid(Source), typeid(Target)))
 #endif
 
-#if (defined(BOOST_LCAST_HAS_INT128) && !defined(__GNUC__)) || GCC_VERSION > 40700
+// GCC 4.6 has some issues with int128 and uint128. Issues were fixed in GCC 4.7
+#if defined(BOOST_HAS_INT128) && (!defined(__GNUC__) || __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ > 6))
 #define BOOST_LCAST_HAS_INT128
 #endif
 
--- boost_1_54_0/boost/cstdint.hpp.vanilla	2013-11-11 13:15:55.499129165 +0100
+++ boost_1_54_0/boost/cstdint.hpp	2013-11-11 13:16:47.054127383 +0100
@@ -41,7 +41,10 @@
 // so we disable use of stdint.h when GLIBC does not define __GLIBC_HAVE_LONG_LONG.
 // See https://svn.boost.org/trac/boost/ticket/3548 and http://sources.redhat.com/bugzilla/show_bug.cgi?id=10990
 //
-#if defined(BOOST_HAS_STDINT_H) && (!defined(__GLIBC__) || defined(__GLIBC_HAVE_LONG_LONG))
+#if defined(BOOST_HAS_STDINT_H)					\
+  && (!defined(__GLIBC__)					\
+      || defined(__GLIBC_HAVE_LONG_LONG)			\
+      || (defined(__GLIBC__) && ((__GLIBC__ > 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ >= 17)))))
 
 // The following #include is an implementation artifact; not part of interface.
 # ifdef __hpux
